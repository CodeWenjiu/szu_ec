

// Instruction Set Architecture简称ISA，是规定cpu指令格式、语义，寄存器定义，异常与中断行为，以及内存模型的一系列规定。
// 不同ISA的CPU往往生态不兼容，在多年的市场竞争过后，目前主流的IS有x86,ARM,RISC-V等，我们的电脑往往使用x86架构，而手机往往使用ARM架构，
// 不过这两个架构都是闭源的商业ISA，为了方便叙述，后面的一些具体例子我都会使用RISC-V架构的Cpu进行叙述

// == 流水线
// 流水线是相当经典的cpu并行化加速手段，通过将cpu执行分为多个阶段，同时执行这些阶段从而在提高频率的同时不大量降低IPC，
// 从而实现了性能的提升，现代很少有cpu不使用流水线技术，即使是你家洗衣机使用的主控(MCU)，也大概率有至少二级流水线(Arm CortexM0+)

// 一个经典的流水线阶段划分(你大概率会在教科书上看到)如图
// #image("processor\Classic_5-Stage_Pipeline.png")

// === 冒险(Hazard)
// 想要实现流水线，需要解决的问题之一就是冒险，冒险分为数据冒险(Data Hazard)和控制冒险(Control Hazard)
// 其中数据冒险分为三种
// - 读后写(RAW)
// - 写后读(WAR)
// - 写后写(WAW)
// 控制冒险即指令跳转，之前执行的指令会决定之后要执行什么指令

// 冒险的本质是指令依赖性与指令并行执行的冲突，因此解决冒险的方式有三种
// - Interlock
// 暂停流水线，直到指令依赖性消除
// - Bypass
// 提前将指令结果转发至前端
// - Speculate
// 猜测依赖指令的指令结果，如果猜测错误再进行纠正，最简单的纠正方式是冲刷流水线

// 解决数据冒险常使用Bypass，而解决控制冒险尝试用Speculate

// === 分支预测
// 解决控制冒险常使用Speculate，但是随便猜测一个跳转结果的正确率非常低，因此一个高效率的分支预测算法是很重要的，
// 现代高性能cpu在分支预测算法上精益求精，往往能够做到相当高的准确率(>95%)

// 分支预测分为静态分支预测和动态分支预测
// - 静态分支预测
// ISA允许显示指定分支指令的静态分支目标，在编程语言中，比如c语言，我们则可以通过使用宏等标志信息来告诉编译器更可能的跳转目标，从而帮助编译器选择更合适的静态跳转目标

// - 动态分支预测\
//     动态分支预测的理论基础有两部分
//     - 时间局部性\
//         同一个分支，上一次的分支目标很可能就是这一次的分支目标
//     - 空间局部性\
//         多个分支有着相关的分支条件，则分支目标也相互关联

// === 乱序执行
// === 多发射

// == 缓存

// == 显式并行性

// === VLIW
// === 向量机
// === 多核
