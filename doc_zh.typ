#import "@preview/tidy:0.4.1"
#import "@preview/cetz:0.3.2": draw, canvas
#import "@preview/circuiteria:0.2.0"

#set text(font: ("Sarasa Term SC Nerd")) 

#set par(first-line-indent: (amount: 2em, all: true))

= 现代处理器架构简述

== 冯诺依曼机
#image("processor/Von_Neumann.excalidraw.svg")
这是现代计算机的基础架构，不过有几个不同之处
- 由于访存速度往往低于cpu处理速度，因此不会每条指令都访问Memory或Input Output，大多数指令只与cpu内部的寄存器交互，只在必要的时候用访存指令访问内存和IO
- 内存和IO没有本质区别，可以将IO视为特殊的内存，或者将内存视为能够存储数据的IO，因此现代计算机在指令层面上往往不再对两者做区分
    - 将内存和设备区分对待的IO访问方式称为PMIO，将其统一的访问方式称为MMIO
    - 现代的cpu往往使用MMIO，某些特殊的cpu使用PMIO，我们日常使用的计算机(x86)同时支持PMIO(USB)和MMIO(PCIE)
- 冯诺依曼机将指令也视为一种特殊的数据存放在内存中，因此指令和数据没有本质区别，都可以被读取和修改，
    因此允许程序运行时修改自身，这种程序称为“自修改程序”
    - 然而现代程序往往不会再在运行期修改自身，这种情况下，指令和数据的特性就很不一样了，前者只读后者却可读写，
        再加上后期的cpu并行化能力允许同时进行取指和访存，
        现在往往会在L1缓存(可以视为Memory的一个子集)中将指令和数据分别存放以达到最高的利用率
=== 指令集
Instruction Set Architecture简称ISA，是规定cpu指令格式、语义，寄存器定义，异常与中断行为，以及内存模型的一系列规定。
不同ISA的CPU往往生态不兼容，在多年的市场竞争过后，目前主流的IS有x86,ARM,RISC-V等，我们的电脑往往使用x86架构，而手机往往使用ARM架构，
不过这两个架构都是闭源的商业ISA，为了方便叙述，后面的一些具体例子我都会使用RISC-V架构的Cpu进行叙述

== 流水线
流水线是相当经典的cpu并行化加速手段，通过将cpu执行分为多个阶段，同时执行这些阶段从而在提高频率的同时不大量降低IPC，
从而实现了性能的提升，现代很少有cpu不使用流水线技术，即使是你家洗衣机使用的主控(MCU)，也大概率有至少二级流水线(Arm CortexM0+)

一个经典的流水线阶段划分(你大概率会在教科书上看到)如图
#image("processor\Classic_5-Stage_Pipeline.png")

=== 冒险(Hazard)
想要实现流水线，需要解决的问题之一就是冒险，冒险分为数据冒险(Data Hazard)和控制冒险(Control Hazard)
其中数据冒险分为三种
- 读后写(RAW)
- 写后读(WAR)
- 写后写(WAW)
控制冒险即指令跳转，之前执行的指令会决定之后要执行什么指令

冒险的本质是指令依赖性与指令并行执行的冲突，因此解决冒险的方式有三种
- Interlock
暂停流水线，直到指令依赖性消除
- Bypass
提前将指令结果转发至前端
- Speculate
猜测依赖指令的指令结果，如果猜测错误再进行纠正，最简单的纠正方式是冲刷流水线

解决数据冒险常使用Bypass，而解决控制冒险尝试用Speculate

=== 分支预测
解决控制冒险常使用Speculate，但是随便猜测一个跳转结果的正确率非常低，因此一个高效率的分支预测算法是很重要的，
现代高性能cpu在分支预测算法上精益求精，往往能够做到相当高的准确率(>95%)

分支预测分为静态分支预测和动态分支预测
- 静态分支预测
ISA允许显示指定分支指令的静态分支目标，在编程语言中，比如c语言，我们则可以通过使用宏等标志信息来告诉编译器更可能的跳转目标，从而帮助编译器选择更合适的静态跳转目标

- 动态分支预测\
    动态分支预测的理论基础有两部分
    - 时间局部性\
        同一个分支，上一次的分支目标很可能就是这一次的分支目标
    - 空间局部性\
        多个分支有着相关的分支条件，则分支目标也相互关联

=== 乱序执行
=== 多发射

== 缓存

== 显式并行性

=== VLIW
=== 向量机
=== 多核
